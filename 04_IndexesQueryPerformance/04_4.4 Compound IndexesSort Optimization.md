**Section 4.4 ‚Äî Compound Indexes & Sort Optimization**, explained clearly with examples, rules, and best practices.

---

# **üìò 4.4 Compound Indexes & Sort Optimization**

A **compound index** is an index built on **two or more fields**.
It helps optimize:

‚úî Multi-field queries
‚úî Sorting
‚úî Range queries
‚úî Covered queries

Proper compound index design greatly improves query performance.

---

# **1Ô∏è‚É£ What is a Compound Index?**

A compound index is defined like this:

### ‚úî Syntax:

```js
db.collection.createIndex({ field1: 1, field2: -1 })
```

* `1` = ascending
* `-1` = descending
* Field order matters

---

## ‚úî Example:

Create compound index on **city** and **age**:

```js
db.users.createIndex({ city: 1, age: -1 })
```

This index stores:

* First sorted by `city`
* Then sorted by `age` (descending)

---

# **2Ô∏è‚É£ Compound Index Use Cases**

A compound index helps with:

### ‚úî Queries that use multiple fields

```js
db.users.find({ city: "Delhi", age: { $gt: 30 } })
```

### ‚úî Sorting on multiple fields

```js
db.users.find().sort({ city: 1, age: -1 })
```

### ‚úî Covered queries

(If projection includes only indexed fields)

### ‚úî Range queries

Using `$gt`, `$lt`, `$gte`, `$lte`

---

# **3Ô∏è‚É£ Compound Index Order Matters (VERY IMPORTANT)**

Index:

```js
{ city: 1, age: 1 }
```

### ‚úî Good for:

* `city`
* `city + age`

### ‚ùå NOT good for:

* `age` only
* Sorting by `age` only

Because **compound indexes follow left-to-right prefix rule**.

---

# **4Ô∏è‚É£ Prefix Rule (Leftmost Rule)**

A query can use a compound index only if it uses the **leftmost field(s)**.

### Example Index:

```js
{ a: 1, b: 1, c: 1 }
```

### ‚úî Queries that use the index:

* `{ a: "x" }`
* `{ a: "x", b: 5 }`
* `{ a: "x", b: 5, c: 10 }`

### ‚ùå Queries NOT using the index:

* `{ b: 5 }`
* `{ c: 10 }`
* `{ b: 5, c: 10 }`

---

# **5Ô∏è‚É£ Sorting Optimization**

MongoDB can only use index for sorting if:

‚úî Index order matches sort order
‚úî Query uses the prefix

---

## ‚úî Example: Sort by City, then Age

### Index:

```js
db.users.createIndex({ city: 1, age: -1 })
```

### Sort Query:

```js
db.users.find().sort({ city: 1, age: -1 })
```

‚Üí **Uses index efficiently**
‚Üí **Very fast**

---

## ‚ùå Example: Wrong Sort Order

Query:

```js
db.users.find().sort({ city: -1, age: -1 })
```

Index:

```js
{ city: 1, age: -1 }
```

This does NOT match ‚Üí MongoDB may perform an **in-memory sort** (slow!):

Check with:

```js
.explain()
```

---

# **6Ô∏è‚É£ Using Compound Index for Filters + Sort Together**

### Example Query:

```js
db.users.find({ city: "Delhi" }).sort({ age: -1 })
```

### Best Index:

```js
db.users.createIndex({ city: 1, age: -1 })
```

‚úî Matches filter
‚úî Matches sort
‚úî Uses index for both ‚Üí Perfect!

---

# **7Ô∏è‚É£ Compound Index with Range Queries**

MongoDB uses the index until the **first range operator** appears, e.g.:

* `$gt`
* `$lt`
* `$gte`
* `$lte`
* `$in`

---

### Example:

Index:

```js
{ city: 1, age: 1, salary: 1 }
```

Query:

```js
{ city: "Delhi", age: { $gt: 30 }, salary: 50000 }
```

MongoDB stops scanning at `$gt`, but the index still helps significantly.

---

# **8Ô∏è‚É£ Examples of GOOD Compound Indexes**

### ‚úî Example 1: Login audit collection

Query:

```js
db.logs.find({ userId: 101 }).sort({ loginTime: -1 })
```

Index:

```js
{ userId: 1, loginTime: -1 }
```

---

### ‚úî Example 2: E-commerce search

Query:

```js
db.products.find({ category: "Shoes" }).sort({ price: 1 })
```

Index:

```js
{ category: 1, price: 1 }
```

---

### ‚úî Example 3: Geographical + date sort

Query:

```js
db.events.find({ city: "Mumbai" }).sort({ eventDate: 1 })
```

Index:

````js
{ city: 1, eventDate: 1 }
}

---

# **9Ô∏è‚É£ Examples of BAD Compound Indexes**

### ‚ùå Example 1: Wrong prefix
Index:
```js
{ age: 1, city: 1 }
````

Query:

```js
{ city: "Delhi" }
```

Cannot use index because prefix is `age`.

---

### ‚ùå Example 2: Too many indexes

Creating:

* `{ name: 1 }`
* `{ name: -1 }`
* `{ name: 1, age: 1 }`
* `{ name: 1, city: 1 }`

This may:

* Slow down writes
* Increase memory usage

Prefer fewer, well-designed indexes.

---

# **üîü Covered Queries with Compound Indexes**

If your projection uses ONLY indexed fields, MongoDB avoids fetching documents.

### Index:

```js
{ city: 1, age: 1, _id: 0 }
```

### Covered Query:

```js
db.users.find(
  { city: "Delhi" },
  { city: 1, age: 1, _id: 0 }
)
```

‚Üí Fastest possible query.

---

# **üéØ Summary of Compound Index Rules**

| Rule                                      | Explanation                    |
| ----------------------------------------- | ------------------------------ |
| Create indexes based on filter + sort     | Solves most performance issues |
| Follow leftmost prefix rule               | Order matters                  |
| Combine equality ‚Üí then range ‚Üí then sort | Best strategy                  |
| Avoid indexing everything                 | Indexes slow down writes       |
| Covered queries are fastest               | Use only indexed fields        |

---


